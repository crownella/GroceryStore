//%GenSrc:1:BBqcSehsi0SL7khHmTYa1w
/*
 * This code was generated by InstinctAI.
 *
 * It is safe to edit this file.
 */

using System.Runtime.CompilerServices;

namespace instinctai.usr.behaviours
{
    using UnityEngine;
    using com.kupio.instinctai;
    using System.Collections.Generic;

    public partial class Customer : MonoBehaviour
    {
        public GroceryItem[] groceryItems; //all possible grocery items
        public Aisle[] aisles; //all items in store
        public Transform[] exitPoints; //all points a customer can go to leave

        //random generated factors
        public int listSize;
        public List<GroceryItem> shoppingList = new List<GroceryItem>(); 
        List<Aisle> checkedAisles = new List<Aisle>(); //keeps track of waht aisles the customer has been on
        public int confusion; //0-100 how confused the shopper is

        private Cart cart;

        //movementManager
        public int lastCheckedAisle;
        private Transform targetLocation;
        public GroceryItem targetGrocery;
        public Aisle currentAisle;
        public int aislesChecked; //how many aisles in store you have checked

        //state manager
        public bool foundAisle; //is not searching for an aisle
        public bool foundItem = true; //is not searching for item
        public bool shoppingDone;
        public bool checkingOut;
        public bool gone;
        public bool spawned;



        




        void Start()
        {
            GameManger gM = GameObject.FindGameObjectWithTag("GameController").GetComponent<GameManger>();
            groceryItems = gM.groceryItemsMaster;
            aisles = gM.aislesMaster;
            exitPoints = gM.exitPointsMaster;
            
            cart = gameObject.GetComponent<Cart>();


            //random generation
            confusion = Random.Range(0, 100);
            listSize = Random.Range(1, 10);
            while(shoppingList.Count < listSize)
            {
                bool inList;
                for (int i = 0; i < groceryItems.Length; i++)
                {
                    inList = false;
                    if(shoppingList.Count >= listSize)
                        break;
                    

                    int randomChance = Random.Range(0, 100);

                    foreach(GroceryItem g in shoppingList)
                    {
                        if (g.Equals(groceryItems[i]))
                        {
                            inList = true;
                        }
                    }

                    if (inList)
                    {
                        continue;
                    }
                    if (randomChance > 50)
                    {
                        shoppingList.Add(groceryItems[i]);
                    }
                }
            }
           
        }

        //deciedes where the customer will start shopping and the next Aisle to go to 
        //found aisle is false
        //foudn item is true
        //spawned is false
        public NodeVal PickFirstAisle()
        {
            Aisle targetAisle = null;
            bool alreadyChecked = false;
            //find first aisle with an item on the shopping list
            for (int i = 0; i < aisles.Length - 1; i++)
            {
                //make sure the aisles isnt on the list on checked asiles first
                /* dont need this in this method
                foreach (Aisle b in checkedAisles)
                {
                    if (aisles[i].Equals(b)){
                        alreadyChecked = true;
                        break;
                    }
                }
                */
                foreach (GroceryItem g in aisles[i].itemsOnShelf)
                {
                    if (alreadyChecked)
                    {
                        break; //cant become target isle
                    }
                    foreach (GroceryItem h in shoppingList)
                    {
                        if (g.Equals(h))
                        {
                            targetAisle = aisles[i];
                            lastCheckedAisle = i;
                            break;
                        }
                    }
                }
            }
            
            //depening on conufsion level, go to the aisle, the first aisle, the last aisle or a random aisle
            if(confusion < 25)
            {
                //no change, only here for readibilty
            }else if(confusion < 50)
            {
                targetAisle = aisles[0];
            }else if(confusion < 75)
            {
                targetAisle = aisles[aisles.Length - 1];
            }
            else
            {
                targetAisle = aisles[Random.Range(0, aisles.Length - 1)];
            }

            currentAisle = targetAisle;
            foundAisle = true;

            //set targetlocation to aisle start points, go to closest one or farthest one if confusion is high
            if (confusion > 75)
            {
                //this returns the furthest check spot from the player
                GameObject worst = null;
                float biggestDistance = 0;
                foreach( GameObject g in targetAisle.shopSpots)
                {
                    if(worst == null) //first object in check spots
                    {
                        worst = g;
                        biggestDistance = Vector3.Distance(g.transform.position, this.transform.position);
                    }
                    else
                    {
                        //if the distance between the next is great
                        float distance = Vector3.Distance(g.transform.position, this.transform.position);
                        if (distance > biggestDistance)
                        {
                            biggestDistance = distance;
                            worst = g;
                        }
                    } 
                }
                targetLocation = worst.transform;
            }
            else
            {
                //thsi return the closest check spot to the player
                GameObject best = null;
                float smallestDistance = 0;
                foreach (GameObject g in targetAisle.shopSpots)
                {
                    if (best == null) //first object in check spots
                    {
                        best = g;
                        smallestDistance = Vector3.Distance(g.transform.position, this.transform.position);
                    }
                    else
                    {
                        //if the distance between the next is great
                        float distance = Vector3.Distance(g.transform.position, this.transform.position);
                        if (distance < smallestDistance)
                        {
                            smallestDistance = distance;
                            best = g;
                        }
                    }
                }
                targetLocation = best.transform;
            }
            spawned = true;
            return NodeVal.Success;
        }


        //picks the next aisle to go to
        //spawned is true
        //found aisle is false
        //foudn item is true
        //shoppingDone is false - which means there is atleast one isle we havent searched yet
        public NodeVal PickAisle()
        {
            Aisle targetAisle = null;
            

            //depening on conufsion level, go to the next aisle with something you need, the next aisle, or a slight chance to go to a random one
            if (confusion < 25)
            {
                //change this later: right now just goes to next aisle
                if (lastCheckedAisle + 1 > aisles.Length - 1)
                {
                    lastCheckedAisle = -1;
                }
                targetAisle = aisles[lastCheckedAisle + 1];
                lastCheckedAisle = lastCheckedAisle + 1;
            }
            else if (confusion < 98)
            {
                if(lastCheckedAisle + 1 > aisles.Length - 1)
                {
                    lastCheckedAisle = -1;
                }
                targetAisle = aisles[lastCheckedAisle + 1];
                lastCheckedAisle = lastCheckedAisle + 1;
            }
            else
            {
                targetAisle = aisles[Random.Range(0, aisles.Length - 1)];
            }

            currentAisle = targetAisle;
            foundAisle = true;

            //set targetlocation to aisle start points, go to closest one or farthest one if confusion is high
            if (confusion > 75)
            {
                //this returns the furthest check spot from the player
                GameObject worst = null;
                float biggestDistance = 0;
                foreach (GameObject g in targetAisle.shopSpots)
                {
                    if (worst == null) //first object in check spots
                    {
                        worst = g;
                        biggestDistance = Vector3.Distance(g.transform.position, this.transform.position);
                    }
                    else
                    {
                        //if the distance between the next is great
                        float distance = Vector3.Distance(g.transform.position, this.transform.position);
                        if (distance > biggestDistance)
                        {
                            biggestDistance = distance;
                            worst = g;
                        }
                    }
                }

                if (worst != null)
                {
                    targetLocation = worst.transform;
                }
                
            }
            else
            {
                //thsi return the closest check spot to the player
                GameObject best = null;
                float smallestDistance = 0;
                foreach (GameObject g in targetAisle.shopSpots)
                {
                    if (best == null) //first object in check spots
                    {
                        best = g;
                        smallestDistance = Vector3.Distance(g.transform.position, this.transform.position);
                    }
                    else
                    {
                        //if the distance between the next is great
                        float distance = Vector3.Distance(g.transform.position, this.transform.position);
                        if (distance < smallestDistance)
                        {
                            smallestDistance = distance;
                            best = g;
                        }
                    }
                }

                if (best != null)
                {
                    targetLocation = best.transform;
                }
            }
            return NodeVal.Success;
        }

        //checks the items on a particular aisle 
        //found aisle is true
        //foudn item is true
        public NodeVal CheckItems()
        {
            //search all items on aisle
            foreach(GroceryItem g in currentAisle.itemsOnShelf)
            {
                foreach (GroceryItem h in shoppingList)
                {
                    if (g.Equals(h))
                    {
                        //if any item is on the shoppin glist, found item is false  set target grocery item
                        targetGrocery = g;
                        targetLocation = targetGrocery.accessSpot;
                        foundItem = false;
                        return NodeVal.Success;
                    }
                }
            }


            //add aisle to list of checked aisles
            checkedAisles.Add(currentAisle);

            //if we have checked all the aisles, we are done shopping
            /*
            if (checkedAisles.Count.Equals(aisles.Length))
            {
                print("checked all aisles");
                shoppingDone = true;
            }
            */

            aislesChecked += 1;

            foundAisle = false;
            return NodeVal.Success;
        }

        //gets the item youre looking for
        //found aisle is true
        //found item is false
        public NodeVal getItem()
        {
            Stock targetStock = targetGrocery.Shelf;
            //take up to 3
            bool successful = targetStock.AddToCart(Random.Range(1, 3), cart, targetGrocery);

            //if the stock was empty
            if (!successful)
            {
                //customer is mad, show emotiocon
                print("Im Mad");

            }

            //done searchign for  item
            foundItem = true;

            //remove the grocery from your shopping list!
            shoppingList.Remove(targetGrocery);
            
            //if everything is off ur shopping list ur done shopping
            if(shoppingList.Count < 1)
            {
                shoppingDone = true;
            }
            
            return NodeVal.Success;
        }


        //joins the cash register queue  //currently just sends the customer to an exit point
        public NodeVal checkout()
        {
            checkingOut = true;

            //thsi return the closest exit point 
            Transform best = null;
            float smallestDistance = 0;
            foreach (Transform t in exitPoints)
            {
                if (best == null) //first object in check spots
                {
                    best = t;
                    smallestDistance = Vector3.Distance(t.position, this.transform.position);
                }
                else
                {
                    //if the distance between the next is great
                    float distance = Vector3.Distance(t.position, this.transform.position);
                    if (distance < smallestDistance)
                    {
                        smallestDistance = distance;
                        best = t;
                    }
                }
            }
            targetLocation = best;

            checkingOut = false;
            return NodeVal.Success;
        }

        //disappears
        public NodeVal Leave()
        {
            Destroy(this.gameObject);
            return NodeVal.Success;
        }

    } 
}
